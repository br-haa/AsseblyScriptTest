{"version":3,"sources":["webpack://asc/webpack/universalModuleDefinition","webpack://asc/webpack/bootstrap","webpack://asc/./shim/fs.js","webpack://asc/./shim/path.js","webpack://asc/./shim/process.js","webpack://asc/. sync","webpack://asc/../node_modules/webpack/buildin/global.js","webpack://asc/./util/colors.js","webpack://asc/./asc.js","webpack://asc/./util/utf8.js","webpack://asc/./util/options.js","webpack://asc/./util/mkdirp.js","webpack://asc/./util/find.js","webpack://asc/external \"binaryen\"","webpack://asc/external \"assemblyscript\""],"names":["root","factory","exports","module","require","e","define","amd","self","this","__WEBPACK_EXTERNAL_MODULE__12__","__WEBPACK_EXTERNAL_MODULE__13__","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","process","assertPath","path","TypeError","JSON","stringify","normalizeStringPosix","allowAboveRoot","code","res","lastSegmentLength","lastSlash","dots","length","charCodeAt","lastSlashIndex","lastIndexOf","slice","posix","resolve","cwd","resolvedPath","resolvedAbsolute","arguments","undefined","normalize","isAbsolute","trailingSeparator","join","joined","arg","relative","from","to","fromStart","fromEnd","fromLen","toStart","toLen","lastCommonSep","fromCode","out","_makeLong","dirname","hasRoot","end","matchedSlash","basename","ext","start","extIdx","firstNonSlashEnd","extname","startDot","startPart","preDotState","format","pathObject","sep","dir","base","_format","parse","ret","delimiter","win32","platform","umask","hrtime","previousTimestamp","clocktime","performanceNow","performance","seconds","Math","floor","nanoseconds","global","now","mozNow","msNow","oNow","webkitNow","Date","getTime","webpackEmptyContext","req","Error","keys","id","g","Function","window","proc","isCI","env","stream","colors","supported","isTTY","gray","text","GRAY","RESET","red","RED","green","GREEN","yellow","YELLOW","blue","BLUE","magenta","MAGENTA","cyan","CYAN","white","WHITE","stdout","stderr","fs","utf8","colorsUtil","optionsUtil","mkdirp","find","binaryen","EOL","SEP","setupExtension","extension","startsWith","ext_d","re","RegExp","re_d","re_except_d","re_index","defaultExtension","assemblyscript","ready","removeAllListeners","isDev","loadAssemblyScript","dynRequire","args","eval","register","project","skipIgnore","compilerOptions","target","e_ts","stack","isBundle","version","options","libraryPrefix","LIBRARY_PREFIX","defaultOptimizeLevel","defaultShrinkLevel","libraryFiles","libDir","bundled","files","forEach","file","replace","readFileSync","definitionFiles","stdDir","compileString","sources","output","createMemoryStream","argv","val","opt","type","push","Array","isArray","String","main","concat","readFile","writeFile","contents","listFiles","callback","readFileNode","writeFileNode","listFilesNode","stats","createStats","opts","noColors","unknown","write","trailing","err","test","help","color","baseDir","asconfig","getAsconfig","config","asconfigDir","seenAsconfig","Set","add","targets","merge","transform","map","entries","entry","extends","fileName","filePath","has","showConfig","resolveBasedir","unique","values","newOptions","setTarget","setNoAssert","noAssert","setExportMemory","noExportMemory","setImportMemory","importMemory","setInitialMemory","initialMemory","setMaximumMemory","maximumMemory","setSharedMemory","sharedMemory","setImportTable","importTable","setExportTable","exportTable","setExplicitStart","explicitStart","setMemoryBase","memoryBase","setTableBase","tableBase","setSourceMap","sourceMap","setNoUnsafe","noUnsafe","setPedantic","pedantic","setLowMemoryLimit","lowMemoryLimit","use","aliases","k","part","indexOf","alias","substring","trim","setGlobalAlias","features","disable","split","flag","toUpperCase","disableFeature","enable","enableFeature","optimizeLevel","shrinkLevel","optimize","min","max","setOptimizeLevelHints","program","newProgram","transforms","tsNodeRegistered","transformArgs","filename","endsWith","transpileOnly","skipProject","classOrModule","paths","assign","log","console","error","applyTransform","transformCount","transfromTime","measure","libPath","parseCount","parseTime","customLibDirs","lib","libFiles","j","libText","packageMains","Map","packageBases","getFile","internalPath","dependeePath","sourceText","sourcePath","plainName","indexName","match","packageName","isPackageRoot","basePath","traceResolution","parts","currentPath","mainPath","jsonPath","jsonText","json","ascMain","set","mainDir","parseBacklog","nextFile","getDependee","numErrors","checkDiagnostics","message","runtimeName","runtime","runtimePath","runtimeText","parser","normalizedPath","sort","initializeCount","initializeTime","initializeProgram","compileCount","compileTime","compile","dispose","noValidate","isValid","validateCount","validateTime","validate","trapMode","optimizeCount","optimizeTime","runPass","debugInfo","debug","usesARC","converge","runPasses","pass","last","toBinary","next","noEmit","outFile","textFile","jsFile","binaryFile","hasStdout","hasOutput","tsdFile","idlFile","wasm","sourceMapURL","emitCount","emitTime","writeStdout","sourceRoot","index","getSource","sourcesContent","wat","toText","idl","buildIDL","tsd","buildTSD","js","toAsmjs","printStats","readCount","readTime","encoding","writeCount","writeTime","dirPath","outputFilePath","existsSync","writeFileSync","readdirSync","filter","used","toString","isObject","location","ex","include","diagnostic","nextDiagnostic","formatDiagnostic","isError","transformTime","fn","times","pad","str","len","formatTime","time","toFixed","count","allocBuffer","Buffer","allocUnsafe","Uint8Array","chunk","buffer","reset","toBuffer","offset","read","tscOptions","alwaysStrict","noImplicitAny","noImplicitReturns","noImplicitThis","noEmitOnError","strictNullChecks","experimentalDecorators","noLib","types","allowJs","string","fromCharCode","apply","c1","c2","sanitizeValue","Boolean","trunc","Number","v","addDefaults","default","defaultValue","propagateDefaults","option","exec","parseInt","parseFloat","indent","padding","eol","sbCategories","sbOther","description","sb","noCategories","category","line","hasCategories","currentOptions","parentOptions","mergedOptions","mutuallyExclusive","currentValue","parentValue","exclude","includes","made","mkdirSync","err0","stat","statSync","err1","isDirectory","findFiles","iname"],"mappings":"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","file":"asc.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"binaryen\"), (function webpackLoadOptionalExternalModule() { try { return require(\"assemblyscript\"); } catch(e) {} }()));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"binaryen\", \"assemblyscript\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"asc\"] = factory(require(\"binaryen\"), (function webpackLoadOptionalExternalModule() { try { return require(\"assemblyscript\"); } catch(e) {} }()));\n\telse\n\t\troot[\"asc\"] = factory(root[\"binaryen\"], root[\"assemblyscript\"]);\n})(typeof self !== 'undefined' ? self : this, function(__WEBPACK_EXTERNAL_MODULE__12__, __WEBPACK_EXTERNAL_MODULE__13__) {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 6);\n","module.exports = {};\n","const process = require(\"process\"); // ensure shim\n\n// https://github.com/browserify/path-browserify v1.0.1\n//\n// Copyright (c) 2013 James Halliday\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction assertPath(path) {\n  if (typeof path !== 'string') {\n    throw new TypeError('Path must be a string. Received ' + JSON.stringify(path));\n  }\n}\n\n// Resolves . and .. elements in a path with directory names\nfunction normalizeStringPosix(path, allowAboveRoot) {\n  var res = '';\n  var lastSegmentLength = 0;\n  var lastSlash = -1;\n  var dots = 0;\n  var code;\n  for (var i = 0; i <= path.length; ++i) {\n    if (i < path.length)\n      code = path.charCodeAt(i);\n    else if (code === 47 /*/*/)\n      break;\n    else\n      code = 47 /*/*/;\n    if (code === 47 /*/*/) {\n      if (lastSlash === i - 1 || dots === 1) {\n        // NOOP\n      } else if (lastSlash !== i - 1 && dots === 2) {\n        if (res.length < 2 || lastSegmentLength !== 2 || res.charCodeAt(res.length - 1) !== 46 || res.charCodeAt(res.length - 2) !== 46) {\n          if (res.length > 2) {\n            var lastSlashIndex = res.lastIndexOf('/');\n            if (lastSlashIndex !== res.length - 1) {\n              if (lastSlashIndex === -1) {\n                res = '';\n                lastSegmentLength = 0;\n              } else {\n                res = res.slice(0, lastSlashIndex);\n                lastSegmentLength = res.length - 1 - res.lastIndexOf('/');\n              }\n              lastSlash = i;\n              dots = 0;\n              continue;\n            }\n          } else if (res.length === 2 || res.length === 1) {\n            res = '';\n            lastSegmentLength = 0;\n            lastSlash = i;\n            dots = 0;\n            continue;\n          }\n        }\n        if (allowAboveRoot) {\n          if (res.length > 0)\n            res += '/..';\n          else\n            res = '..';\n          lastSegmentLength = 2;\n        }\n      } else {\n        if (res.length > 0)\n          res += '/' + path.slice(lastSlash + 1, i);\n        else\n          res = path.slice(lastSlash + 1, i);\n        lastSegmentLength = i - lastSlash - 1;\n      }\n      lastSlash = i;\n      dots = 0;\n    } else if (code === 46 && dots !== -1) {\n      ++dots;\n    } else {\n      dots = -1;\n    }\n  }\n  return res;\n}\n\nfunction _format(sep, pathObject) {\n  var dir = pathObject.dir || pathObject.root;\n  var base = pathObject.base || (pathObject.name || '') + (pathObject.ext || '');\n  if (!dir) {\n    return base;\n  }\n  if (dir === pathObject.root) {\n    return dir + base;\n  }\n  return dir + sep + base;\n}\n\nvar posix = {\n  // path.resolve([from ...], to)\n  resolve: function resolve() {\n    var resolvedPath = '';\n    var resolvedAbsolute = false;\n    var cwd;\n\n    for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n      var path;\n      if (i >= 0)\n        path = arguments[i];\n      else {\n        if (cwd === undefined)\n          cwd = process.cwd();\n        path = cwd;\n      }\n\n      assertPath(path);\n\n      // Skip empty entries\n      if (path.length === 0) {\n        continue;\n      }\n\n      resolvedPath = path + '/' + resolvedPath;\n      resolvedAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    }\n\n    // At this point the path should be resolved to a full absolute path, but\n    // handle relative paths to be safe (might happen when process.cwd() fails)\n\n    // Normalize the path\n    resolvedPath = normalizeStringPosix(resolvedPath, !resolvedAbsolute);\n\n    if (resolvedAbsolute) {\n      if (resolvedPath.length > 0)\n        return '/' + resolvedPath;\n      else\n        return '/';\n    } else if (resolvedPath.length > 0) {\n      return resolvedPath;\n    } else {\n      return '.';\n    }\n  },\n\n  normalize: function normalize(path) {\n    assertPath(path);\n\n    if (path.length === 0) return '.';\n\n    var isAbsolute = path.charCodeAt(0) === 47 /*/*/;\n    var trailingSeparator = path.charCodeAt(path.length - 1) === 47 /*/*/;\n\n    // Normalize the path\n    path = normalizeStringPosix(path, !isAbsolute);\n\n    if (path.length === 0 && !isAbsolute) path = '.';\n    if (path.length > 0 && trailingSeparator) path += '/';\n\n    if (isAbsolute) return '/' + path;\n    return path;\n  },\n\n  isAbsolute: function isAbsolute(path) {\n    assertPath(path);\n    return path.length > 0 && path.charCodeAt(0) === 47 /*/*/;\n  },\n\n  join: function join() {\n    if (arguments.length === 0)\n      return '.';\n    var joined;\n    for (var i = 0; i < arguments.length; ++i) {\n      var arg = arguments[i];\n      assertPath(arg);\n      if (arg.length > 0) {\n        if (joined === undefined)\n          joined = arg;\n        else\n          joined += '/' + arg;\n      }\n    }\n    if (joined === undefined)\n      return '.';\n    return posix.normalize(joined);\n  },\n\n  relative: function relative(from, to) {\n    assertPath(from);\n    assertPath(to);\n\n    if (from === to) return '';\n\n    from = posix.resolve(from);\n    to = posix.resolve(to);\n\n    if (from === to) return '';\n\n    if (from === \".\") return to; // FIX for 'odule.ts' (see issue #1398)\n\n    // Trim any leading backslashes\n    var fromStart = 1;\n    for (; fromStart < from.length; ++fromStart) {\n      if (from.charCodeAt(fromStart) !== 47 /*/*/)\n        break;\n    }\n    var fromEnd = from.length;\n    var fromLen = fromEnd - fromStart;\n\n    // Trim any leading backslashes\n    var toStart = 1;\n    for (; toStart < to.length; ++toStart) {\n      if (to.charCodeAt(toStart) !== 47 /*/*/)\n        break;\n    }\n    var toEnd = to.length;\n    var toLen = toEnd - toStart;\n\n    // Compare paths to find the longest common path from root\n    var length = fromLen < toLen ? fromLen : toLen;\n    var lastCommonSep = -1;\n    var i = 0;\n    for (; i <= length; ++i) {\n      if (i === length) {\n        if (toLen > length) {\n          if (to.charCodeAt(toStart + i) === 47 /*/*/) {\n            // We get here if `from` is the exact base path for `to`.\n            // For example: from='/foo/bar'; to='/foo/bar/baz'\n            return to.slice(toStart + i + 1);\n          } else if (i === 0) {\n            // We get here if `from` is the root\n            // For example: from='/'; to='/foo'\n            return to.slice(toStart + i);\n          }\n        } else if (fromLen > length) {\n          if (from.charCodeAt(fromStart + i) === 47 /*/*/) {\n            // We get here if `to` is the exact base path for `from`.\n            // For example: from='/foo/bar/baz'; to='/foo/bar'\n            lastCommonSep = i;\n          } else if (i === 0) {\n            // We get here if `to` is the root.\n            // For example: from='/foo'; to='/'\n            lastCommonSep = 0;\n          }\n        }\n        break;\n      }\n      var fromCode = from.charCodeAt(fromStart + i);\n      var toCode = to.charCodeAt(toStart + i);\n      if (fromCode !== toCode)\n        break;\n      else if (fromCode === 47 /*/*/)\n        lastCommonSep = i;\n    }\n\n    var out = '';\n    // Generate the relative path based on the path difference between `to`\n    // and `from`\n    for (i = fromStart + lastCommonSep + 1; i <= fromEnd; ++i) {\n      if (i === fromEnd || from.charCodeAt(i) === 47 /*/*/) {\n        if (out.length === 0)\n          out += '..';\n        else\n          out += '/..';\n      }\n    }\n\n    // Lastly, append the rest of the destination (`to`) path that comes after\n    // the common path parts\n    if (out.length > 0)\n      return out + to.slice(toStart + lastCommonSep);\n    else {\n      toStart += lastCommonSep;\n      if (to.charCodeAt(toStart) === 47 /*/*/)\n        ++toStart;\n      return to.slice(toStart);\n    }\n  },\n\n  _makeLong: function _makeLong(path) {\n    return path;\n  },\n\n  dirname: function dirname(path) {\n    assertPath(path);\n    if (path.length === 0) return '.';\n    var code = path.charCodeAt(0);\n    var hasRoot = code === 47 /*/*/;\n    var end = -1;\n    var matchedSlash = true;\n    for (var i = path.length - 1; i >= 1; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n        if (!matchedSlash) {\n          end = i;\n          break;\n        }\n      } else {\n        // We saw the first non-path separator\n        matchedSlash = false;\n      }\n    }\n\n    if (end === -1) return hasRoot ? '/' : '.';\n    if (hasRoot && end === 1) return '//';\n    return path.slice(0, end);\n  },\n\n  basename: function basename(path, ext) {\n    if (ext !== undefined && typeof ext !== 'string') throw new TypeError('\"ext\" argument must be a string');\n    assertPath(path);\n\n    var start = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i;\n\n    if (ext !== undefined && ext.length > 0 && ext.length <= path.length) {\n      if (ext.length === path.length && ext === path) return '';\n      var extIdx = ext.length - 1;\n      var firstNonSlashEnd = -1;\n      for (i = path.length - 1; i >= 0; --i) {\n        var code = path.charCodeAt(i);\n        if (code === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else {\n          if (firstNonSlashEnd === -1) {\n            // We saw the first non-path separator, remember this index in case\n            // we need it if the extension ends up not matching\n            matchedSlash = false;\n            firstNonSlashEnd = i + 1;\n          }\n          if (extIdx >= 0) {\n            // Try to match the explicit extension\n            if (code === ext.charCodeAt(extIdx)) {\n              if (--extIdx === -1) {\n                // We matched the extension, so mark this as the end of our path\n                // component\n                end = i;\n              }\n            } else {\n              // Extension does not match, so our result is the entire path\n              // component\n              extIdx = -1;\n              end = firstNonSlashEnd;\n            }\n          }\n        }\n      }\n\n      if (start === end) end = firstNonSlashEnd;else if (end === -1) end = path.length;\n      return path.slice(start, end);\n    } else {\n      for (i = path.length - 1; i >= 0; --i) {\n        if (path.charCodeAt(i) === 47 /*/*/) {\n          // If we reached a path separator that was not part of a set of path\n          // separators at the end of the string, stop now\n          if (!matchedSlash) {\n            start = i + 1;\n            break;\n          }\n        } else if (end === -1) {\n          // We saw the first non-path separator, mark this as the end of our\n          // path component\n          matchedSlash = false;\n          end = i + 1;\n        }\n      }\n\n      if (end === -1) return '';\n      return path.slice(start, end);\n    }\n  },\n\n  extname: function extname(path) {\n    assertPath(path);\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n    for (var i = path.length - 1; i >= 0; --i) {\n      var code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1)\n          startDot = i;\n        else if (preDotState !== 1)\n          preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n        // We saw a non-dot character immediately before the dot\n        preDotState === 0 ||\n        // The (right-most) trimmed path component is exactly '..'\n        preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      return '';\n    }\n    return path.slice(startDot, end);\n  },\n\n  format: function format(pathObject) {\n    if (pathObject === null || typeof pathObject !== 'object') {\n      throw new TypeError('The \"pathObject\" argument must be of type Object. Received type ' + typeof pathObject);\n    }\n    return _format('/', pathObject);\n  },\n\n  parse: function parse(path) {\n    assertPath(path);\n\n    var ret = { root: '', dir: '', base: '', ext: '', name: '' };\n    if (path.length === 0) return ret;\n    var code = path.charCodeAt(0);\n    var isAbsolute = code === 47 /*/*/;\n    var start;\n    if (isAbsolute) {\n      ret.root = '/';\n      start = 1;\n    } else {\n      start = 0;\n    }\n    var startDot = -1;\n    var startPart = 0;\n    var end = -1;\n    var matchedSlash = true;\n    var i = path.length - 1;\n\n    // Track the state of characters (if any) we see before our first dot and\n    // after any path separator we find\n    var preDotState = 0;\n\n    // Get non-dir info\n    for (; i >= start; --i) {\n      code = path.charCodeAt(i);\n      if (code === 47 /*/*/) {\n        // If we reached a path separator that was not part of a set of path\n        // separators at the end of the string, stop now\n        if (!matchedSlash) {\n          startPart = i + 1;\n          break;\n        }\n        continue;\n      }\n      if (end === -1) {\n        // We saw the first non-path separator, mark this as the end of our\n        // extension\n        matchedSlash = false;\n        end = i + 1;\n      }\n      if (code === 46) {\n        // If this is our first dot, mark it as the start of our extension\n        if (startDot === -1) startDot = i;else if (preDotState !== 1) preDotState = 1;\n      } else if (startDot !== -1) {\n        // We saw a non-dot and non-path separator before our dot, so we should\n        // have a good chance at having a non-empty extension\n        preDotState = -1;\n      }\n    }\n\n    if (startDot === -1 || end === -1 ||\n    // We saw a non-dot character immediately before the dot\n    preDotState === 0 ||\n    // The (right-most) trimmed path component is exactly '..'\n    preDotState === 1 && startDot === end - 1 && startDot === startPart + 1) {\n      if (end !== -1) {\n        if (startPart === 0 && isAbsolute) ret.base = ret.name = path.slice(1, end);else ret.base = ret.name = path.slice(startPart, end);\n      }\n    } else {\n      if (startPart === 0 && isAbsolute) {\n        ret.name = path.slice(1, startDot);\n        ret.base = path.slice(1, end);\n      } else {\n        ret.name = path.slice(startPart, startDot);\n        ret.base = path.slice(startPart, end);\n      }\n      ret.ext = path.slice(startDot, end);\n    }\n\n    if (startPart > 0) ret.dir = path.slice(0, startPart - 1);else if (isAbsolute) ret.dir = '/';\n\n    return ret;\n  },\n\n  sep: '/',\n  delimiter: ':',\n  win32: null,\n  posix: null\n};\n\nposix.posix = posix;\n\nmodule.exports = posix;\n","module.exports = {\n  platform: \"linux\",\n  cwd() {\n    return \".\";\n  },\n  umask() {\n    return 0;\n  },\n  hrtime\n};\n\n// https://github.com/kumavis/browser-process-hrtime v1.0.0\n//\n// Copyright 2014 kumavis\n//\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//\n// 1. Redistributions of source code must retain the above copyright notice,\n// this list of conditions and the following disclaimer.\n//\n// 2. Redistributions in binary form must reproduce the above copyright notice,\n// this list of conditions and the following disclaimer in the documentation\n// and/or other materials provided with the distribution.\n//\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n// POSSIBILITY OF SUCH DAMAGE.\n\nvar performance = global.performance || {};\nvar performanceNow =\n  performance.now        ||\n  performance.mozNow     ||\n  performance.msNow      ||\n  performance.oNow       ||\n  performance.webkitNow  ||\n  function(){ return (new Date()).getTime(); };\n\nfunction hrtime(previousTimestamp) {\n  var clocktime = performanceNow.call(performance) * 1e-3;\n  var seconds = Math.floor(clocktime);\n  var nanoseconds = Math.floor((clocktime % 1) * 1e9);\n  if (previousTimestamp) {\n    seconds = seconds - previousTimestamp[0];\n    nanoseconds = nanoseconds - previousTimestamp[1];\n    if (nanoseconds < 0) {\n      seconds--;\n      nanoseconds += 1e9;\n    }\n  }\n  return [ seconds, nanoseconds ];\n}\n","function webpackEmptyContext(req) {\n\tvar e = new Error(\"Cannot find module '\" + req + \"'\");\n\te.code = 'MODULE_NOT_FOUND';\n\tthrow e;\n}\nwebpackEmptyContext.keys = function() { return []; };\nwebpackEmptyContext.resolve = webpackEmptyContext;\nmodule.exports = webpackEmptyContext;\nwebpackEmptyContext.id = 3;","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/**\n * @fileoverview Terminal colors utility.\n * @license Apache-2.0\n */\n\nvar proc = typeof process !== \"undefined\" && process || {};\nvar isCI = proc.env && \"CI\" in proc.env; // doesn't work when bundled because 'process' is a mock\n\nfunction from(stream, base) {\n  var colors = base || {};\n  colors.supported = (stream && !!stream.isTTY) || isCI;\n  colors.gray = text => colors.supported ? exports.GRAY + text + exports.RESET : text;\n  colors.red = text => colors.supported ? exports.RED + text + exports.RESET : text;\n  colors.green = text => colors.supported ? exports.GREEN + text + exports.RESET : text;\n  colors.yellow = text => colors.supported ? exports.YELLOW + text + exports.RESET : text;\n  colors.blue = text => colors.supported ? exports.BLUE + text + exports.RESET : text;\n  colors.magenta = text => colors.supported ? exports.MAGENTA + text + exports.RESET : text;\n  colors.cyan = text => colors.supported ? exports.CYAN + text + exports.RESET : text;\n  colors.white = text => colors.supported ? exports.WHITE + text + exports.RESET : text;\n  return colors;\n}\n\nexports.stdout = from(proc.stdout, exports);\nexports.stderr = from(proc.stderr);\nexports.from = from;\n\nexports.GRAY = \"\\u001b[90m\";\nexports.RED = \"\\u001b[91m\";\nexports.GREEN = \"\\u001b[92m\";\nexports.YELLOW = \"\\u001b[93m\";\nexports.BLUE = \"\\u001b[94m\";\nexports.MAGENTA = \"\\u001b[95m\";\nexports.CYAN = \"\\u001b[96m\";\nexports.WHITE = \"\\u001b[97m\";\nexports.RESET = \"\\u001b[0m\";\n","/**\n * @license\n * Copyright 2020 Daniel Wirtz / The AssemblyScript Authors.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Compiler frontend for node.js\n *\n * Uses the low-level API exported from src/index.ts so it works with the compiler compiled to\n * JavaScript as well as the compiler compiled to WebAssembly (eventually). Runs the sources\n * directly through ts-node if distribution files are not present (indicated by a `-dev` version).\n *\n * Can also be packaged as a bundle suitable for in-browser use with the standard library injected\n * in the build step. See dist/asc.js for the bundle and webpack.config.js for building details.\n */\n\n/* global BUNDLE_VERSION, BUNDLE_LIBRARY, BUNDLE_DEFINITIONS */\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\nconst process = require(\"process\"); // ensure shim\n\nconst utf8 = require(\"./util/utf8\");\nconst colorsUtil = require(\"./util/colors\");\nconst optionsUtil = require(\"./util/options\");\nconst mkdirp = require(\"./util/mkdirp\");\nconst find = require(\"./util/find\");\nconst binaryen = global.binaryen || (global.binaryen = require(\"binaryen\"));\n\nconst EOL = process.platform === \"win32\" ? \"\\r\\n\" : \"\\n\";\nconst SEP = process.platform === \"win32\" ? \"\\\\\" : \"/\";\n\n// Sets up an extension with its definition counterpart and relevant regexes.\nfunction setupExtension(extension) {\n  if (!extension.startsWith(\".\")) extension = \".\" + extension;\n  return {\n    ext: extension,\n    ext_d: \".d\" + extension,\n    re: new RegExp(\"\\\\\" + extension + \"$\"),\n    re_d: new RegExp(\"\\\\.d\\\\\" + extension + \"$\"),\n    re_except_d: new RegExp(\"^(?!.*\\\\.d\\\\\" + extension + \"$).*\\\\\" + extension + \"$\"),\n    re_index: new RegExp(\"(?:^|[\\\\\\\\\\\\/])index\\\\\" + extension + \"$\")\n  };\n}\n\nconst defaultExtension = setupExtension(\".ts\");\n\n// Proxy Binaryen's ready event\nObject.defineProperty(exports, \"ready\", {\n  get: function() { return binaryen.ready; }\n});\n\n// Emscripten adds an `uncaughtException` listener to Binaryen that results in an additional\n// useless code fragment on top of an actual error. suppress this:\nif (process.removeAllListeners) process.removeAllListeners(\"uncaughtException\");\n\n// Use distribution files if present, otherwise run the sources directly.\nvar assemblyscript;\nvar isDev = false;\n(function loadAssemblyScript() {\n  try {\n    assemblyscript = require(\"assemblyscript\");\n  } catch (e) {\n    function dynRequire(...args) {\n      return eval(\"require\")(...args);\n    }\n    try { // `asc` on the command line\n      assemblyscript = dynRequire(\"../dist/assemblyscript.js\");\n    } catch (e) {\n      try { // `asc` on the command line without dist files\n        dynRequire(\"ts-node\").register({\n          project: path.join(__dirname, \"..\", \"src\", \"tsconfig.json\"),\n          skipIgnore: true,\n          compilerOptions: { target: \"ES2016\" }\n        });\n        dynRequire(\"../src/glue/js\");\n        assemblyscript = dynRequire(\"../src\");\n        isDev = true;\n      } catch (e_ts) {\n        try { // `require(\"dist/asc.js\")` in explicit browser tests\n          assemblyscript = dynRequire(\"./assemblyscript\");\n        } catch (e) {\n          throw Error(e_ts.stack + \"\\n---\\n\" + e.stack);\n        }\n      }\n    }\n  }\n})();\n\n/** Whether this is a webpack bundle or not. */\nexports.isBundle = typeof BUNDLE_VERSION === \"string\";\n\n/** Whether asc runs the sources directly or not. */\nexports.isDev = isDev;\n\n/** AssemblyScript version. */\nexports.version = exports.isBundle ? BUNDLE_VERSION : require(\"../package.json\").version;\n\n/** Available CLI options. */\nexports.options = require(\"./asc.json\");\n\n/** Prefix used for library files. */\nexports.libraryPrefix = assemblyscript.LIBRARY_PREFIX;\n\n/** Default Binaryen optimization level. */\nexports.defaultOptimizeLevel = 3;\n\n/** Default Binaryen shrink level. */\nexports.defaultShrinkLevel = 1;\n\n/** Bundled library files. */\nexports.libraryFiles = exports.isBundle ? BUNDLE_LIBRARY : (() => { // set up if not a bundle\n  const libDir = path.join(__dirname, \"..\", \"std\", \"assembly\");\n  const bundled = {};\n  find\n    .files(libDir, defaultExtension.re_except_d)\n    .forEach(file => bundled[file.replace(defaultExtension.re, \"\")] = fs.readFileSync(path.join(libDir, file), \"utf8\" ));\n  return bundled;\n})();\n\n/** Bundled definition files. */\nexports.definitionFiles = exports.isBundle ? BUNDLE_DEFINITIONS : (() => { // set up if not a bundle\n  const stdDir = path.join(__dirname, \"..\", \"std\");\n  return {\n    \"assembly\": fs.readFileSync(path.join(stdDir, \"assembly\", \"index\" + defaultExtension.ext_d), \"utf8\"),\n    \"portable\": fs.readFileSync(path.join(stdDir, \"portable\", \"index\" + defaultExtension.ext_d), \"utf8\")\n  };\n})();\n\n/** Convenience function that parses and compiles source strings directly. */\nexports.compileString = (sources, options) => {\n  if (typeof sources === \"string\") sources = { [\"input\" + defaultExtension.ext]: sources };\n  const output = Object.create({\n    stdout: createMemoryStream(),\n    stderr: createMemoryStream()\n  });\n  var argv = [\n    \"--binaryFile\", \"binary\",\n    \"--textFile\", \"text\",\n  ];\n  Object.keys(options || {}).forEach(key => {\n    var val = options[key];\n    var opt = exports.options[key];\n    if (opt && opt.type === \"b\") {\n      if (val) argv.push(\"--\" + key);\n    } else {\n      if (Array.isArray(val)) val.forEach(val => argv.push(\"--\" + key, String(val)));\n      else argv.push(\"--\" + key, String(val));\n    }\n  });\n  exports.main(argv.concat(Object.keys(sources)), {\n    stdout: output.stdout,\n    stderr: output.stderr,\n    readFile: name => Object.prototype.hasOwnProperty.call(sources, name) ? sources[name] : null,\n    writeFile: (name, contents) => output[name] = contents,\n    listFiles: () => []\n  });\n  return output;\n};\n\n/** Runs the command line utility using the specified arguments array. */\nexports.main = function main(argv, options, callback) {\n  if (typeof options === \"function\") {\n    callback = options;\n    options = {};\n  } else if (!options) {\n    options = {};\n  }\n\n  const stdout = options.stdout || process.stdout;\n  const stderr = options.stderr || process.stderr;\n  const readFile = options.readFile || readFileNode;\n  const writeFile = options.writeFile || writeFileNode;\n  const listFiles = options.listFiles || listFilesNode;\n  const stats = options.stats || createStats();\n  let extension = defaultExtension;\n\n  // Output must be specified if not present in the environment\n  if (!stdout) throw Error(\"'options.stdout' must be specified\");\n  if (!stderr) throw Error(\"'options.stderr' must be specified\");\n\n  const opts = optionsUtil.parse(argv, exports.options);\n  let args = opts.options;\n\n  argv = opts.arguments;\n  if (args.noColors) {\n    colorsUtil.stdout.supported =\n    colorsUtil.stderr.supported = false;\n  } else {\n    colorsUtil.stdout = colorsUtil.from(stdout);\n    colorsUtil.stderr = colorsUtil.from(stderr);\n  }\n\n  // Check for unknown arguments\n  if (opts.unknown.length) {\n    opts.unknown.forEach(arg => {\n      stderr.write(colorsUtil.stderr.yellow(\"WARNING \") + \"Unknown option '\" + arg + \"'\" + EOL);\n    });\n  }\n\n  // Check for trailing arguments\n  if (opts.trailing.length) {\n    stderr.write(colorsUtil.stderr.yellow(\"WARNING \") + \"Unsupported trailing arguments: \" + opts.trailing.join(\" \") + EOL);\n  }\n\n  // Use default callback if none is provided\n  if (!callback) callback = function defaultCallback(err) {\n    var code = 0;\n    if (err) {\n      stderr.write(colorsUtil.stderr.red(\"FAILURE \") + err.stack.replace(/^ERROR: /i, \"\") + EOL);\n      code = 1;\n    }\n    return code;\n  };\n\n  // Just print the version if requested\n  if (args.version) {\n    stdout.write(\"Version \" + exports.version + (isDev ? \"-dev\" : \"\") + EOL);\n    return callback(null);\n  }\n\n  // Use another extension if requested\n  if (typeof args.extension === \"string\") {\n    if (/^\\.?[0-9a-zA-Z]{1,14}$/.test(args.extension)) {\n      extension = setupExtension(args.extension);\n    } else {\n      return callback(Error(\"Invalid extension: \" + args.extension));\n    }\n  }\n\n  // Print the help message if requested or no source files are provided\n  if (args.help || !argv.length) {\n    var out = args.help ? stdout : stderr;\n    var color = args.help ? colorsUtil.stdout : colorsUtil.stderr;\n    out.write([\n      color.white(\"SYNTAX\"),\n      \"  \" + color.cyan(\"asc\") + \" [entryFile ...] [options]\",\n      \"\",\n      color.white(\"EXAMPLES\"),\n      \"  \" + color.cyan(\"asc\") + \" hello\" + extension.ext,\n      \"  \" + color.cyan(\"asc\") + \" hello\" + extension.ext + \" -b hello.wasm -t hello.wat\",\n      \"  \" + color.cyan(\"asc\") + \" hello1\" + extension.ext + \" hello2\" + extension.ext + \" -b -O > hello.wasm\",\n      \"\",\n      color.white(\"OPTIONS\"),\n    ].concat(\n      optionsUtil.help(exports.options, 24, EOL)\n    ).join(EOL) + EOL);\n    return callback(null);\n  }\n\n  // I/O must be specified if not present in the environment\n  if (!fs.readFileSync) {\n    if (readFile === readFileNode) throw Error(\"'options.readFile' must be specified\");\n    if (writeFile === writeFileNode) throw Error(\"'options.writeFile' must be specified\");\n    if (listFiles === listFilesNode) throw Error(\"'options.listFiles' must be specified\");\n  }\n\n  // Set up base directory\n  const baseDir = args.baseDir ? path.resolve(args.baseDir) : \".\";\n  const target = args.target;\n\n  // Once the baseDir is calculated, we can resolve the config, and its extensions\n  let asconfig = getAsconfig(args.config, baseDir, readFile);\n  let asconfigDir = baseDir;\n\n  const seenAsconfig = new Set();\n  seenAsconfig.add(path.join(baseDir, args.config));\n\n  while (asconfig) {\n    // merge target first, then merge options, then merge extended asconfigs\n    if (asconfig.targets && asconfig.targets[target]) {\n      args = optionsUtil.merge(exports.options, asconfig.targets[target], args);\n    }\n    if (asconfig.options) {\n      if (asconfig.options.transform) {\n        // ensure that a transform's path is relative to the current config\n        asconfig.options.transform = asconfig.options.transform.map(p => {\n          if (!path.isAbsolute(p)) {\n            if (p.startsWith(\".\")) {\n              return path.join(asconfigDir, p);\n            }\n            return require.resolve(p);\n          }\n          return p;\n        });\n      }\n      args = optionsUtil.merge(exports.options, args, asconfig.options);\n    }\n\n    // entries are added to the compilation\n    if (asconfig.entries) {\n      for (const entry of asconfig.entries) {\n        argv.push(\n          path.isAbsolute(entry)\n            ? entry\n            // the entry is relative to the asconfig directory\n            : path.join(asconfigDir, entry)\n        );\n      }\n    }\n\n    // asconfig \"extends\" another config, merging options of it's parent\n    if (asconfig.extends) {\n      asconfigDir = path.isAbsolute(asconfig.extends)\n        // absolute extension path means we know the exact directory and location\n        ? path.dirname(asconfig.extends)\n        // relative means we need to calculate a relative asconfigDir\n        : path.join(asconfigDir, path.dirname(asconfig.extends));\n      const fileName = path.basename(asconfig.extends);\n      const filePath = path.join(asconfigDir, fileName);\n      if (seenAsconfig.has(filePath)) {\n        asconfig = null;\n      } else {\n        seenAsconfig.add(filePath);\n        asconfig = getAsconfig(fileName, asconfigDir, readFile);\n      }\n    } else {\n      asconfig = null; // finished resolving the configuration chain\n    }\n  }\n\n  // If showConfig print args and exit\n  if (args.showConfig) {\n    stderr.write(JSON.stringify(args, null, 2));\n    return callback(null);\n  }\n\n  // This method resolves a path relative to the baseDir instead of process.cwd()\n  function resolveBasedir(arg) {\n    return path.resolve(baseDir, arg);\n  }\n\n  // create a unique set of values\n  function unique(values) {\n    return [...new Set(values)];\n  }\n\n  // returns a relative path from baseDir\n  function makeRelative(arg) {\n    return path.relative(baseDir, arg);\n  }\n\n  // postprocess we need to get absolute file locations argv\n  argv = unique(argv.map(resolveBasedir)).map(makeRelative);\n\n  // Set up options\n  const compilerOptions = assemblyscript.newOptions();\n  assemblyscript.setTarget(compilerOptions, 0);\n  assemblyscript.setNoAssert(compilerOptions, args.noAssert);\n  assemblyscript.setExportMemory(compilerOptions, !args.noExportMemory);\n  assemblyscript.setImportMemory(compilerOptions, args.importMemory);\n  assemblyscript.setInitialMemory(compilerOptions, args.initialMemory >>> 0);\n  assemblyscript.setMaximumMemory(compilerOptions, args.maximumMemory >>> 0);\n  assemblyscript.setSharedMemory(compilerOptions, args.sharedMemory);\n  assemblyscript.setImportTable(compilerOptions, args.importTable);\n  assemblyscript.setExportTable(compilerOptions, args.exportTable);\n  assemblyscript.setExplicitStart(compilerOptions, args.explicitStart);\n  assemblyscript.setMemoryBase(compilerOptions, args.memoryBase >>> 0);\n  assemblyscript.setTableBase(compilerOptions, args.tableBase >>> 0);\n  assemblyscript.setSourceMap(compilerOptions, args.sourceMap != null);\n  assemblyscript.setNoUnsafe(compilerOptions, args.noUnsafe);\n  assemblyscript.setPedantic(compilerOptions, args.pedantic);\n  assemblyscript.setLowMemoryLimit(compilerOptions, args.lowMemoryLimit >>> 0);\n\n  // Add or override aliases if specified\n  if (args.use) {\n    let aliases = args.use;\n    for (let i = 0, k = aliases.length; i < k; ++i) {\n      let part = aliases[i];\n      let p = part.indexOf(\"=\");\n      if (p < 0) return callback(Error(\"Global alias '\" + part + \"' is invalid.\"));\n      let alias = part.substring(0, p).trim();\n      let name = part.substring(p + 1).trim();\n      if (!alias.length) return callback(Error(\"Global alias '\" + part + \"' is invalid.\"));\n      assemblyscript.setGlobalAlias(compilerOptions, alias, name);\n    }\n  }\n\n  // Disable default features if specified\n  var features;\n  if ((features = args.disable) != null) {\n    if (typeof features === \"string\") features = features.split(\",\");\n    for (let i = 0, k = features.length; i < k; ++i) {\n      let name = features[i].trim();\n      let flag = assemblyscript[\"FEATURE_\" + name.replace(/-/g, \"_\").toUpperCase()];\n      if (!flag) return callback(Error(\"Feature '\" + name + \"' is unknown.\"));\n      assemblyscript.disableFeature(compilerOptions, flag);\n    }\n  }\n\n  // Enable experimental features if specified\n  if ((features = args.enable) != null) {\n    if (typeof features === \"string\") features = features.split(\",\");\n    for (let i = 0, k = features.length; i < k; ++i) {\n      let name = features[i].trim();\n      let flag = assemblyscript[\"FEATURE_\" + name.replace(/-/g, \"_\").toUpperCase()];\n      if (!flag) return callback(Error(\"Feature '\" + name + \"' is unknown.\"));\n      assemblyscript.enableFeature(compilerOptions, flag);\n    }\n  }\n\n  // Set up optimization levels\n  var optimizeLevel = 0;\n  var shrinkLevel = 0;\n  if (args.optimize) {\n    optimizeLevel = exports.defaultOptimizeLevel;\n    shrinkLevel = exports.defaultShrinkLevel;\n  }\n  if (typeof args.optimizeLevel === \"number\") optimizeLevel = args.optimizeLevel;\n  if (typeof args.shrinkLevel === \"number\") shrinkLevel = args.shrinkLevel;\n  optimizeLevel = Math.min(Math.max(optimizeLevel, 0), 3);\n  shrinkLevel = Math.min(Math.max(shrinkLevel, 0), 2);\n  assemblyscript.setOptimizeLevelHints(compilerOptions, optimizeLevel, shrinkLevel);\n\n  // Initialize the program\n  const program = assemblyscript.newProgram(compilerOptions);\n\n  // Set up transforms\n  const transforms = [];\n  if (args.transform) {\n    let tsNodeRegistered = false;\n    let transformArgs = unique(args.transform.map(resolveBasedir));\n    for (let i = 0, k = transformArgs.length; i < k; ++i) {\n      let filename = transformArgs[i].trim();\n      if (!tsNodeRegistered && filename.endsWith(\".ts\")) { // ts-node requires .ts specifically\n        require(\"ts-node\").register({ transpileOnly: true, skipProject: true, compilerOptions: { target: \"ES2016\" } });\n        tsNodeRegistered = true;\n      }\n      try {\n        const classOrModule = require(require.resolve(filename, { paths: [baseDir, process.cwd()] }));\n        if (typeof classOrModule === \"function\") {\n          Object.assign(classOrModule.prototype, {\n            program,\n            baseDir,\n            stdout,\n            stderr,\n            log: console.error,\n            readFile,\n            writeFile,\n            listFiles\n          });\n          transforms.push(new classOrModule());\n        } else {\n          transforms.push(classOrModule); // legacy module\n        }\n      } catch (e) {\n        return callback(e);\n      }\n    }\n  }\n\n  function applyTransform(name, ...args) {\n    for (let i = 0, k = transforms.length; i < k; ++i) {\n      let transform = transforms[i];\n      if (typeof transform[name] === \"function\") {\n        try {\n          stats.transformCount++;\n          stats.transfromTime += measure(() => {\n            transform[name](...args);\n          });\n        } catch (e) {\n          return e;\n        }\n      }\n    }\n  }\n\n  // Parse library files\n  Object.keys(exports.libraryFiles).forEach(libPath => {\n    if (libPath.indexOf(\"/\") >= 0) return; // in sub-directory: imported on demand\n    stats.parseCount++;\n    stats.parseTime += measure(() => {\n      assemblyscript.parse(program, exports.libraryFiles[libPath], exports.libraryPrefix + libPath + extension.ext, false);\n    });\n  });\n  let customLibDirs = [];\n  if (args.lib) {\n    let lib = args.lib;\n    if (typeof lib === \"string\") lib = lib.trim().split(/\\s*,\\s*/);\n    customLibDirs.push(...lib.map(resolveBasedir));\n    customLibDirs = unique(customLibDirs); // `lib` and `customLibDirs` may include duplicates\n    for (let i = 0, k = customLibDirs.length; i < k; ++i) { // custom\n      let libDir = customLibDirs[i];\n      let libFiles;\n      if (libDir.endsWith(extension.ext)) {\n        libFiles = [ path.basename(libDir) ];\n        libDir = path.dirname(libDir);\n      } else {\n        libFiles = listFiles(libDir, baseDir) || [];\n      }\n      for (let j = 0, l = libFiles.length; j < l; ++j) {\n        let libPath = libFiles[j];\n        let libText = readFile(libPath, libDir);\n        if (libText === null) return callback(Error(\"Library file '\" + libPath + \"' not found.\"));\n        stats.parseCount++;\n        exports.libraryFiles[libPath.replace(extension.re, \"\")] = libText;\n        stats.parseTime += measure(() => {\n          assemblyscript.parse(program, libText, exports.libraryPrefix + libPath, false);\n        });\n      }\n    }\n  }\n  args.path = args.path || [];\n\n  // Maps package names to parent directory\n  var packageMains = new Map();\n  var packageBases = new Map();\n\n  // Gets the file matching the specified source path, imported at the given dependee path\n  function getFile(internalPath, dependeePath) {\n    var sourceText = null; // text reported back to the compiler\n    var sourcePath = null; // path reported back to the compiler\n\n    const libraryPrefix = exports.libraryPrefix;\n    const libraryFiles = exports.libraryFiles;\n\n    // Try file.ext, file/index.ext, file.d.ext\n    if (!internalPath.startsWith(libraryPrefix)) {\n      if ((sourceText = readFile(sourcePath = internalPath + extension.ext, baseDir)) == null) {\n        if ((sourceText = readFile(sourcePath = internalPath + \"/index\" + extension.ext, baseDir)) == null) {\n          // portable d.ext: uses the .js file next to it in JS or becomes an import in Wasm\n          sourcePath = internalPath + extension.ext;\n          sourceText = readFile(internalPath + extension.ext_d, baseDir);\n        }\n      }\n\n    // Search library in this order: stdlib, custom lib dirs, paths\n    } else {\n      const plainName = internalPath.substring(libraryPrefix.length);\n      const indexName = plainName + \"/index\";\n      if (Object.prototype.hasOwnProperty.call(libraryFiles, plainName)) {\n        sourceText = libraryFiles[plainName];\n        sourcePath = libraryPrefix + plainName + extension.ext;\n      } else if (Object.prototype.hasOwnProperty.call(libraryFiles, indexName)) {\n        sourceText = libraryFiles[indexName];\n        sourcePath = libraryPrefix + indexName + extension.ext;\n      } else { // custom lib dirs\n        for (const libDir of customLibDirs) {\n          if ((sourceText = readFile(plainName + extension.ext, libDir)) != null) {\n            sourcePath = libraryPrefix + plainName + extension.ext;\n            break;\n          } else {\n            if ((sourceText = readFile(indexName + extension.ext, libDir)) != null) {\n              sourcePath = libraryPrefix + indexName + extension.ext;\n              break;\n            }\n          }\n        }\n        if (sourceText == null) { // paths\n          const match = internalPath.match(/^~lib\\/((?:@[^/]+\\/)?[^/]+)(?:\\/(.+))?/); // ~lib/(pkg)/(path), ~lib/(@org/pkg)/(path)\n          if (match) {\n            const packageName = match[1];\n            const isPackageRoot = match[2] === undefined;\n            const filePath = isPackageRoot ? \"index\" : match[2];\n            const basePath = packageBases.has(dependeePath) ? packageBases.get(dependeePath) : \".\";\n            if (args.traceResolution) stderr.write(\"Looking for package '\" + packageName + \"' file '\" + filePath + \"' relative to '\" + basePath + \"'\" + EOL);\n            const absBasePath = path.isAbsolute(basePath) ? basePath : path.join(baseDir, basePath);\n            const paths = [];\n            for (let parts = absBasePath.split(SEP), i = parts.length, k = SEP == \"/\" ? 0 : 1; i >= k; --i) {\n              if (parts[i - 1] !== \"node_modules\") paths.push(parts.slice(0, i).join(SEP) + SEP + \"node_modules\");\n            }\n            for (const currentPath of paths.concat(...args.path).map(p => path.relative(baseDir, p))) {\n              if (args.traceResolution) stderr.write(\"  in \" + path.join(currentPath, packageName) + EOL);\n              let mainPath = \"assembly\";\n              if (packageMains.has(packageName)) { // use cached\n                mainPath = packageMains.get(packageName);\n              } else { // evaluate package.json\n                let jsonPath = path.join(currentPath, packageName, \"package.json\");\n                let jsonText = readFile(jsonPath, baseDir);\n                if (jsonText != null) {\n                  try {\n                    let json = JSON.parse(jsonText);\n                    if (typeof json.ascMain === \"string\") {\n                      mainPath = json.ascMain.replace(extension.re_index, \"\");\n                      packageMains.set(packageName, mainPath);\n                    }\n                  } catch (e) { /* nop */ }\n                }\n              }\n              const mainDir = path.join(currentPath, packageName, mainPath);\n              const plainName = filePath;\n              if ((sourceText = readFile(path.join(mainDir, plainName + extension.ext), baseDir)) != null) {\n                sourcePath = libraryPrefix + packageName + \"/\" + plainName + extension.ext;\n                packageBases.set(sourcePath.replace(extension.re, \"\"), path.join(currentPath, packageName));\n                if (args.traceResolution) stderr.write(\"  -> \" + path.join(mainDir, plainName + extension.ext) + EOL);\n                break;\n              } else if (!isPackageRoot) {\n                const indexName = filePath + \"/index\";\n                if ((sourceText = readFile(path.join(mainDir, indexName + extension.ext), baseDir)) !== null) {\n                  sourcePath = libraryPrefix + packageName + \"/\" + indexName + extension.ext;\n                  packageBases.set(sourcePath.replace(extension.re, \"\"), path.join(currentPath, packageName));\n                  if (args.traceResolution) stderr.write(\"  -> \" + path.join(mainDir, indexName + extension.ext) + EOL);\n                  break;\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    // No such file\n    if (sourceText == null) return null;\n    return { sourceText, sourcePath };\n  }\n\n  // Parses the backlog of imported files after including entry files\n  function parseBacklog() {\n    var internalPath;\n    while ((internalPath = assemblyscript.nextFile(program)) != null) {\n      let file = getFile(internalPath, assemblyscript.getDependee(program, internalPath));\n      if (file) {\n        stats.parseCount++;\n        stats.parseTime += measure(() => {\n          assemblyscript.parse(program, file.sourceText, file.sourcePath, false);\n        });\n      } else {\n        assemblyscript.parse(program, null, internalPath + extension.ext, false);\n      }\n    }\n    var numErrors = checkDiagnostics(program, stderr);\n    if (numErrors) {\n      const err = Error(numErrors + \" parse error(s)\");\n      err.stack = err.message; // omit stack\n      return callback(err);\n    }\n  }\n\n  // Include runtime template before entry files so its setup runs first\n  {\n    let runtimeName = String(args.runtime);\n    let runtimePath = \"rt/index-\" + runtimeName;\n    let runtimeText = exports.libraryFiles[runtimePath];\n    if (runtimeText == null) {\n      runtimePath = runtimeName;\n      runtimeText = readFile(runtimePath + extension.ext, baseDir);\n      if (runtimeText == null) return callback(Error(\"Runtime '\" + runtimeName + \"' not found.\"));\n    } else {\n      runtimePath = \"~lib/\" + runtimePath;\n    }\n    stats.parseCount++;\n    stats.parseTime += measure(() => {\n      assemblyscript.parse(program, runtimeText, runtimePath + extension.ext, true);\n    });\n  }\n\n  // Include entry files\n  for (let i = 0, k = argv.length; i < k; ++i) {\n    const filename = argv[i];\n\n    let sourcePath = String(filename).replace(/\\\\/g, \"/\").replace(extension.re, \"\").replace(/[\\\\/]$/, \"\");\n\n    // Setting the path to relative path\n    sourcePath = path.isAbsolute(sourcePath) ? path.relative(baseDir, sourcePath) : sourcePath;\n\n    // Try entryPath.ext, then entryPath/index.ext\n    let sourceText = readFile(sourcePath + extension.ext, baseDir);\n    if (sourceText == null) {\n      sourceText = readFile(sourcePath + \"/index\" + extension.ext, baseDir);\n      if (sourceText != null) sourcePath += \"/index\" + extension.ext;\n      else sourcePath += extension.ext;\n    } else {\n      sourcePath += extension.ext;\n    }\n\n    stats.parseCount++;\n    stats.parseTime += measure(() => {\n      assemblyscript.parse(program, sourceText, sourcePath, true);\n    });\n  }\n\n  // Parse entry files\n  {\n    let code = parseBacklog();\n    if (code) return code;\n  }\n\n  // Call afterParse transform hook\n  {\n    let error = applyTransform(\"afterParse\", program.parser);\n    if (error) return callback(error);\n  }\n\n  // Parse additional files, if any\n  {\n    let code = parseBacklog();\n    if (code) return code;\n  }\n\n  // Print files and exit if listFiles\n  if (args.listFiles) {\n    // FIXME: not a proper C-like API\n    stderr.write(program.sources.map(s => s.normalizedPath).sort().join(EOL) + EOL);\n    return callback(null);\n  }\n\n  // Pre-emptively initialize the program\n  stats.initializeCount++;\n  stats.initializeTime += measure(() => {\n    assemblyscript.initializeProgram(program);\n  });\n\n  // Call afterInitialize transform hook\n  {\n    let error = applyTransform(\"afterInitialize\", program);\n    if (error) return callback(error);\n  }\n\n  var module;\n  stats.compileCount++;\n  stats.compileTime += measure(() => {\n    module = assemblyscript.compile(program);\n  });\n  var numErrors = checkDiagnostics(program, stderr);\n  if (numErrors) {\n    if (module) module.dispose();\n    const err = Error(numErrors + \" compile error(s)\");\n    err.stack = err.message; // omit stack\n    return callback(err);\n  }\n\n  // Call afterCompile transform hook\n  {\n    let error = applyTransform(\"afterCompile\", module);\n    if (error) return callback(error);\n  }\n\n  // Validate the module if requested\n  if (!args.noValidate) {\n    stats.validateCount++;\n    let isValid;\n    stats.validateTime += measure(() => {\n      isValid = module.validate();\n    });\n    if (!isValid) {\n      module.dispose();\n      return callback(Error(\"validate error\"));\n    }\n  }\n\n  // Set Binaryen-specific options\n  if (args.trapMode === \"clamp\") {\n    stats.optimizeCount++;\n    stats.optimizeTime += measure(() => {\n      module.runPass(\"trap-mode-clamp\");\n    });\n  } else if (args.trapMode === \"js\") {\n    stats.optimizeCount++;\n    stats.optimizeTime += measure(() => {\n      module.runPass(\"trap-mode-js\");\n    });\n  } else if (args.trapMode !== \"allow\") {\n    module.dispose();\n    return callback(Error(\"Unsupported trap mode\"));\n  }\n\n  // Optimize the module\n  const debugInfo = args.debug;\n  const usesARC = args.runtime == \"half\" || args.runtime == \"full\";\n  const converge = args.converge;\n  const runPasses = [];\n  if (args.runPasses) {\n    if (typeof args.runPasses === \"string\") {\n      args.runPasses = args.runPasses.split(\",\");\n    }\n    if (args.runPasses.length) {\n      args.runPasses.forEach(pass => {\n        if (runPasses.indexOf(pass = pass.trim()) < 0)\n          runPasses.push(pass);\n      });\n    }\n  }\n\n  stats.optimizeTime += measure(() => {\n    stats.optimizeCount++;\n    module.optimize(optimizeLevel, shrinkLevel, debugInfo, usesARC);\n    module.runPasses(runPasses);\n    if (converge) {\n      let last = module.toBinary();\n      do {\n        stats.optimizeCount++;\n        module.optimize(optimizeLevel, shrinkLevel, debugInfo, usesARC);\n        module.runPasses(runPasses);\n        let next = module.toBinary();\n        if (next.output.length >= last.output.length) {\n          if (next.output.length > last.output.length) {\n            stderr.write(\"Last converge was suboptimial.\" + EOL);\n          }\n          break;\n        }\n        last = next;\n      } while (true);\n    }\n  });\n\n  // Prepare output\n  if (!args.noEmit) {\n    if (args.outFile != null) {\n      if (/\\.was?t$/.test(args.outFile) && args.textFile == null) {\n        args.textFile = args.outFile;\n      } else if (/\\.js$/.test(args.outFile) && args.jsFile == null) {\n        args.jsFile = args.outFile;\n      } else if (args.binaryFile == null) {\n        args.binaryFile = args.outFile;\n      }\n    }\n\n    let hasStdout = false;\n    let hasOutput = args.textFile != null\n                 || args.binaryFile != null\n                 || args.jsFile != null\n                 || args.tsdFile != null\n                 || args.idlFile != null;\n\n    // Write binary\n    if (args.binaryFile != null) {\n      let basename = path.basename(args.binaryFile);\n      let sourceMapURL = args.sourceMap != null\n        ? args.sourceMap.length\n          ? args.sourceMap\n          : \"./\" + basename + \".map\"\n        : null;\n\n      let wasm;\n      stats.emitCount++;\n      stats.emitTime += measure(() => {\n        wasm = module.toBinary(sourceMapURL);\n      });\n\n      if (args.binaryFile.length) {\n        writeFile(args.binaryFile, wasm.output, baseDir);\n      } else {\n        writeStdout(wasm.output);\n        hasStdout = true;\n      }\n\n      // Post-process source map\n      if (wasm.sourceMap != null) {\n        if (args.binaryFile.length) {\n          let map = JSON.parse(wasm.sourceMap);\n          map.sourceRoot = \"./\" + basename;\n          let contents = [];\n          map.sources.forEach((name, index) => {\n            let text = assemblyscript.getSource(program, name.replace(extension.re, \"\"));\n            if (text == null) return callback(Error(\"Source of file '\" + name + \"' not found.\"));\n            contents[index] = text;\n          });\n          map.sourcesContent = contents;\n          writeFile(path.join(\n            path.dirname(args.binaryFile),\n            path.basename(sourceMapURL)\n          ).replace(/^\\.\\//, \"\"), JSON.stringify(map), baseDir);\n        } else {\n          stderr.write(\"Skipped source map (stdout already occupied)\" + EOL);\n        }\n      }\n    }\n\n    // Write text (also fallback)\n    if (args.textFile != null || !hasOutput) {\n      let wat;\n      if (args.textFile != null && args.textFile.length) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          wat = module.toText();\n        });\n        writeFile(args.textFile, wat, baseDir);\n      } else if (!hasStdout) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          wat = module.toText();\n        });\n        writeStdout(wat);\n      }\n    }\n\n    // Write WebIDL\n    if (args.idlFile != null) {\n      let idl;\n      if (args.idlFile.length) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          idl = assemblyscript.buildIDL(program);\n        });\n        writeFile(args.idlFile, idl, baseDir);\n      } else if (!hasStdout) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          idl = assemblyscript.buildIDL(program);\n        });\n        writeStdout(idl);\n        hasStdout = true;\n      }\n    }\n\n    // Write TypeScript definition\n    if (args.tsdFile != null) {\n      let tsd;\n      if (args.tsdFile.length) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          tsd = assemblyscript.buildTSD(program);\n        });\n        writeFile(args.tsdFile, tsd, baseDir);\n      } else if (!hasStdout) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          tsd = assemblyscript.buildTSD(program);\n        });\n        writeStdout(tsd);\n        hasStdout = true;\n      }\n    }\n\n    // Write JS (modifies the binary, so must be last)\n    if (args.jsFile != null) {\n      let js;\n      if (args.jsFile.length) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          js = module.toAsmjs();\n        });\n        writeFile(args.jsFile, js, baseDir);\n      } else if (!hasStdout) {\n        stats.emitCount++;\n        stats.emitTime += measure(() => {\n          js = module.toAsmjs();\n        });\n        writeStdout(js);\n      }\n    }\n  }\n\n  module.dispose();\n  if (args.measure) {\n    printStats(stats, stderr);\n  }\n\n  return callback(null);\n\n  function readFileNode(filename, baseDir) {\n    let name = path.resolve(baseDir, filename);\n    try {\n      let text;\n      stats.readCount++;\n      stats.readTime += measure(() => {\n        text = fs.readFileSync(name, { encoding: \"utf8\" });\n      });\n      return text;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  function writeFileNode(filename, contents, baseDir) {\n    try {\n      stats.writeCount++;\n      stats.writeTime += measure(() => {\n        const dirPath = path.resolve(baseDir, path.dirname(filename));\n        filename = path.basename(filename);\n        const outputFilePath = path.join(dirPath, filename);\n        if (!fs.existsSync(dirPath)) mkdirp(dirPath);\n        if (typeof contents === \"string\") {\n          fs.writeFileSync(outputFilePath, contents, { encoding: \"utf8\" } );\n        } else {\n          fs.writeFileSync(outputFilePath, contents);\n        }\n      });\n      return true;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  function listFilesNode(dirname, baseDir) {\n    var files;\n    try {\n      stats.readCount++;\n      stats.readTime += measure(() => {\n        files = fs.readdirSync(path.join(baseDir, dirname)).filter(file => extension.re_except_d.test(file));\n      });\n      return files;\n    } catch (e) {\n      return null;\n    }\n  }\n\n  function writeStdout(contents) {\n    if (!writeStdout.used) {\n      stats.writeCount++;\n      writeStdout.used = true;\n    }\n    stats.writeTime += measure(() => {\n      if (typeof contents === \"string\") {\n        stdout.write(contents, { encoding: \"utf8\" });\n      } else {\n        stdout.write(contents);\n      }\n    });\n  }\n};\n\nconst toString = Object.prototype.toString;\n\nfunction isObject(arg) {\n  return toString.call(arg) === \"[object Object]\";\n}\n\nfunction getAsconfig(file, baseDir, readFile) {\n  const contents = readFile(file, baseDir);\n  const location = path.join(baseDir, file);\n  if (!contents) return null;\n\n  // obtain the configuration\n  let config;\n  try {\n    config = JSON.parse(contents);\n  } catch(ex) {\n    throw new Error(\"Asconfig is not valid json: \" + location);\n  }\n\n  // validate asconfig shape\n  if (config.options && !isObject(config.options)) {\n    throw new Error(\"Asconfig.options is not an object: \" + location);\n  }\n\n  if (config.include && !Array.isArray(config.include)) {\n    throw new Error(\"Asconfig.include is not an array: \" + location);\n  }\n\n  if (config.targets) {\n    if (!isObject(config.targets)) {\n      throw new Error(\"Asconfig.targets is not an object: \" + location);\n    }\n    const targets = Object.keys(config.targets);\n    for (let i = 0; i < targets.length; i++) {\n      const target = targets[i];\n      if (!isObject(config.targets[target])) {\n        throw new Error(\"Asconfig.targets.\" + target + \" is not an object: \" + location);\n      }\n    }\n  }\n\n  if (config.extends && typeof config.extends !== \"string\") {\n    throw new Error(\"Asconfig.extends is not a string: \" + location);\n  }\n\n  return config;\n}\n\nexports.getAsconfig = getAsconfig;\n\n/** Checks diagnostics emitted so far for errors. */\nfunction checkDiagnostics(program, stderr) {\n  var diagnostic;\n  var numErrors = 0;\n  while ((diagnostic = assemblyscript.nextDiagnostic(program)) != null) {\n    if (stderr) {\n      stderr.write(\n        assemblyscript.formatDiagnostic(diagnostic, stderr.isTTY, true) +\n        EOL + EOL\n      );\n    }\n    if (assemblyscript.isError(diagnostic)) ++numErrors;\n  }\n  return numErrors;\n}\n\nexports.checkDiagnostics = checkDiagnostics;\n\n/** Creates an empty set of stats. */\nfunction createStats() {\n  return {\n    readTime: 0,\n    readCount: 0,\n    writeTime: 0,\n    writeCount: 0,\n    parseTime: 0,\n    parseCount: 0,\n    initializeTime: 0,\n    initializeCount: 0,\n    compileTime: 0,\n    compileCount: 0,\n    emitTime: 0,\n    emitCount: 0,\n    validateTime: 0,\n    validateCount: 0,\n    optimizeTime: 0,\n    optimizeCount: 0,\n    transformTime: 0,\n    transformCount: 0\n  };\n}\n\nexports.createStats = createStats;\n\n/** Measures the execution time of the specified function.  */\nfunction measure(fn) {\n  const start = process.hrtime();\n  fn();\n  const times = process.hrtime(start);\n  return times[0] * 1e9 + times[1];\n}\n\nexports.measure = measure;\n\nfunction pad(str, len) {\n  while (str.length < len) str = \" \" + str;\n  return str;\n}\n\n/** Formats a high resolution time to a human readable string. */\nfunction formatTime(time) {\n  return time ? (time / 1e6).toFixed(3) + \" ms\" : \"n/a\";\n}\n\nexports.formatTime = formatTime;\n\n/** Formats and prints out the contents of a set of stats. */\nfunction printStats(stats, output) {\n  function format(time, count) {\n    return pad(formatTime(time), 12) + \"  n=\" + count;\n  }\n  (output || process.stdout).write([\n    \"I/O Read   : \" + format(stats.readTime, stats.readCount),\n    \"I/O Write  : \" + format(stats.writeTime, stats.writeCount),\n    \"Parse      : \" + format(stats.parseTime, stats.parseCount),\n    \"Initialize : \" + format(stats.initializeTime, stats.initializeCount),\n    \"Compile    : \" + format(stats.compileTime, stats.compileCount),\n    \"Emit       : \" + format(stats.emitTime, stats.emitCount),\n    \"Validate   : \" + format(stats.validateTime, stats.validateCount),\n    \"Optimize   : \" + format(stats.optimizeTime, stats.optimizeCount),\n    \"Transform  : \" + format(stats.transformTime, stats.transformCount)\n  ].join(EOL) + EOL);\n}\n\nexports.printStats = printStats;\n\nvar allocBuffer = typeof global !== \"undefined\" && global.Buffer\n  ? global.Buffer.allocUnsafe || function(len) { return new global.Buffer(len); }\n  : function(len) { return new Uint8Array(len); };\n\n/** Creates a memory stream that can be used in place of stdout/stderr. */\nfunction createMemoryStream(fn) {\n  var stream = [];\n  stream.write = function(chunk) {\n    if (fn) fn(chunk);\n    if (typeof chunk === \"string\") {\n      let buffer = allocBuffer(utf8.length(chunk));\n      utf8.write(chunk, buffer, 0);\n      chunk = buffer;\n    }\n    this.push(chunk);\n  };\n  stream.reset = function() {\n    stream.length = 0;\n  };\n  stream.toBuffer = function() {\n    var offset = 0, i = 0, k = this.length;\n    while (i < k) offset += this[i++].length;\n    var buffer = allocBuffer(offset);\n    offset = i = 0;\n    while (i < k) {\n      buffer.set(this[i], offset);\n      offset += this[i].length;\n      ++i;\n    }\n    return buffer;\n  };\n  stream.toString = function() {\n    var buffer = this.toBuffer();\n    return utf8.read(buffer, 0, buffer.length);\n  };\n  return stream;\n}\n\nexports.createMemoryStream = createMemoryStream;\n\n/** Compatible TypeScript compiler options for syntax highlighting etc. */\nexports.tscOptions = {\n  alwaysStrict: true,\n  noImplicitAny: true,\n  noImplicitReturns: true,\n  noImplicitThis: true,\n  noEmitOnError: true,\n  strictNullChecks: true,\n  experimentalDecorators: true,\n  target: \"esnext\",\n  module: \"commonjs\",\n  noLib: true,\n  types: [],\n  allowJs: false\n};\n","/**\n * @fileoverview UTF8 utility.\n * @license Apache-2.0\n */\n\n// @protobufjs/utf8\n\n/**\n * A minimal UTF8 implementation for number arrays.\n * @memberof util\n * @namespace\n */\nvar utf8 = exports;\n\n/**\n * Calculates the UTF8 byte length of a string.\n * @param {string} string String\n * @returns {number} Byte length\n */\nutf8.length = function utf8_length(string) {\n  var len = 0,\n      c = 0;\n  for (var i = 0, l = string.length; i < l; ++i) {\n    c = string.charCodeAt(i);\n    if (c < 128)\n      len += 1;\n    else if (c < 2048)\n      len += 2;\n    else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\n      ++i;\n      len += 4;\n    } else\n      len += 3;\n  }\n  return len;\n};\n\n/**\n * Reads UTF8 bytes as a string.\n * @param {Uint8Array} buffer Source buffer\n * @param {number} start Source start\n * @param {number} end Source end\n * @returns {string} String read\n */\nutf8.read = function utf8_read(buffer, start, end) {\n  var len = end - start;\n  if (len < 1)\n    return \"\";\n  var parts = null,\n      chunk = [],\n      i = 0, // char offset\n      t;     // temporary\n  while (start < end) {\n    t = buffer[start++];\n    if (t < 128)\n      chunk[i++] = t;\n    else if (t > 191 && t < 224)\n      chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\n    else if (t > 239 && t < 365) {\n      t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\n      chunk[i++] = 0xD800 + (t >> 10);\n      chunk[i++] = 0xDC00 + (t & 1023);\n    } else\n      chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\n    if (i > 8191) {\n      (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\n      i = 0;\n    }\n  }\n  if (parts) {\n    if (i)\n      parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\n    return parts.join(\"\");\n  }\n  return String.fromCharCode.apply(String, chunk.slice(0, i));\n};\n\n/**\n * Writes a string as UTF8 bytes.\n * @param {string} string Source string\n * @param {Uint8Array} buffer Destination buffer\n * @param {number} offset Destination offset\n * @returns {number} Bytes written\n */\nutf8.write = function utf8_write(string, buffer, offset) {\n  var start = offset,\n      c1, // character 1\n      c2; // character 2\n  for (var i = 0; i < string.length; ++i) {\n    c1 = string.charCodeAt(i);\n    if (c1 < 128) {\n      buffer[offset++] = c1;\n    } else if (c1 < 2048) {\n      buffer[offset++] = c1 >> 6 | 192;\n      buffer[offset++] = c1 & 63 | 128;\n    } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\n      c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\n      ++i;\n      buffer[offset++] = c1 >> 18 | 240;\n      buffer[offset++] = c1 >> 12 & 63 | 128;\n      buffer[offset++] = c1 >> 6 & 63 | 128;\n      buffer[offset++] = c1 & 63 | 128;\n    } else {\n      buffer[offset++] = c1 >> 12 | 224;\n      buffer[offset++] = c1 >> 6 & 63 | 128;\n      buffer[offset++] = c1 & 63 | 128;\n    }\n  }\n  return offset - start;\n};\n","/**\n * @fileoverview Command line options utility.\n * @license Apache-2.0\n */\n\nconst colorsUtil = require(\"./colors\");\n\n// type | meaning\n// -----|---------------\n// b    | boolean\n// i    | integer\n// f    | float\n// s    | string\n// I    | integer array\n// F    | float array\n// S    | string array\n\n/** Parses the specified command line arguments according to the given configuration. */\nfunction parse(argv, config, propagateDefaults = true) {\n  var options = {};\n  var unknown = [];\n  var args = [];\n  var trailing = [];\n\n  // make an alias map and initialize defaults\n  var aliases = {};\n  Object.keys(config).forEach(key => {\n    if (key.startsWith(\" \")) return;\n    var option = config[key];\n    if (option.alias != null) {\n      if (typeof option.alias === \"string\") aliases[option.alias] = key;\n      else if (Array.isArray(option.alias)) option.alias.forEach(alias => aliases[alias] = key);\n    }\n    if (option.default != null) options[key] = option.default;\n  });\n\n  // iterate over argv\n  for (var i = 0, k = (argv = argv.slice()).length; i < k; ++i) {\n    let arg = argv[i];\n    if (arg == \"--\") { ++i; break; }\n    let match = /^(?:(-\\w)(?:=(.*))?|(--\\w{2,})(?:=(.*))?)$/.exec(arg), option, key;\n    if (match) {\n      if (config[arg]) option = config[key = arg]; // exact\n      else if (match[1] != null) { // alias\n        option = config[key = aliases[match[1].substring(1)]];\n        if (option && match[2] != null) argv[i--] = match[2];\n      } else if (match[3] != null) { // full\n        option = config[key = match[3].substring(2)];\n        if (option && match[4] != null) argv[i--] = match[4];\n      }\n    } else {\n      if (arg.charCodeAt(0) == 45) option = config[key = arg]; // exact\n      else { args.push(arg); continue; } // argument\n    }\n    if (option) {\n      if (option.value) {\n        // alias setting fixed values\n        Object.keys(option.value).forEach(k => options[k] = option.value[k]);\n      } else if (option.type == null || option.type === \"b\") {\n        // boolean flag not taking a value\n        options[key] = true;\n      } else {\n        if (i + 1 < argv.length && argv[i + 1].charCodeAt(0) != 45) {\n          // non-boolean with given value\n          switch (option.type) {\n            case \"i\": options[key] = parseInt(argv[++i], 10); break;\n            case \"I\": options[key] = (options[key] || []).concat(parseInt(argv[++i], 10)); break;\n            case \"f\": options[key] = parseFloat(argv[++i]); break;\n            case \"F\": options[key] = (options[key] || []).concat(parseFloat(argv[++i])); break;\n            case \"s\": options[key] = String(argv[++i]); break;\n            case \"S\": options[key] = (options[key] || []).concat(argv[++i].split(\",\")); break;\n            default: unknown.push(arg); --i;\n          }\n        } else {\n          // non-boolean with omitted value\n          switch (option.type) {\n            case \"i\":\n            case \"f\": options[key] = option.default || 0; break;\n            case \"s\": options[key] = option.default || \"\"; break;\n            case \"I\":\n            case \"F\":\n            case \"S\": options[key] = option.default || []; break;\n            default: unknown.push(arg);\n          }\n        }\n      }\n    } else unknown.push(arg);\n  }\n  while (i < k) trailing.push(argv[i++]); // trailing\n  if (propagateDefaults) addDefaults(config, options);\n\n  return { options, unknown, arguments: args, trailing };\n}\n\nexports.parse = parse;\n\n/** Generates the help text for the specified configuration. */\nfunction help(config, options) {\n  if (!options) options = {};\n  var indent = options.indent || 2;\n  var padding = options.padding || 24;\n  var eol = options.eol || \"\\n\";\n  var sbCategories = {};\n  var sbOther = [];\n  Object.keys(config).forEach(key => {\n    var option = config[key];\n    if (option.description == null) return;\n    var text = \"\";\n    while (text.length < indent) text += \" \";\n    text += \"--\" + key;\n    if (option.alias) text += \", -\" + option.alias;\n    while (text.length < padding) text += \" \";\n    var sb;\n    if (!options.noCategories && option.category) {\n      if (!(sb = sbCategories[option.category])) {\n        sbCategories[option.category] = sb = [];\n      }\n    } else {\n      sb = sbOther;\n    }\n    if (Array.isArray(option.description)) {\n      sb.push(text + option.description[0] + option.description.slice(1).map(line => {\n        for (let i = 0; i < padding; ++i) line = \" \" + line;\n        return eol + line;\n      }).join(\"\"));\n    } else sb.push(text + option.description);\n  });\n  var sb = [];\n  var hasCategories = false;\n  Object.keys(sbCategories).forEach(category => {\n    hasCategories = true;\n    sb.push(eol + \" \" + colorsUtil.gray(category) + eol);\n    sb.push(sbCategories[category].join(eol));\n  });\n  if (hasCategories) {\n    sb.push(eol + \" \" + colorsUtil.gray(\"Other\") + eol);\n  }\n  sb.push(sbOther.join(eol));\n  return sb.join(eol);\n}\n\nexports.help = help;\n\n/** Sanitizes an option value to be a valid value of the option's type. */\nfunction sanitizeValue(value, type) {\n  if (value != null) {\n    switch (type) {\n      case undefined:\n      case \"b\": return Boolean(value);\n      case \"i\": return Math.trunc(value) || 0;\n      case \"f\": return Number(value) || 0;\n      case \"s\": {\n        if (value === true) return \"\";\n        return String(value);\n      }\n      case \"I\": {\n        if (!Array.isArray(value)) value = [ value ];\n        return value.map(v => Math.trunc(v) || 0);\n      }\n      case \"F\": {\n        if (!Array.isArray(value)) value = [ value ];\n        return value.map(v => Number(v) || 0);\n      }\n      case \"S\": {\n        if (!Array.isArray(value)) value = [ value ];\n        return value.map(String);\n      }\n    }\n  }\n  return undefined;\n}\n\n/** Merges two sets of options into one, preferring the current over the parent set. */\nfunction merge(config, currentOptions, parentOptions) {\n  const mergedOptions = {};\n  for (const [key, { type, mutuallyExclusive }] of Object.entries(config)) {\n    let currentValue = sanitizeValue(currentOptions[key], type);\n    let parentValue = sanitizeValue(parentOptions[key], type);\n    if (currentValue == null) {\n      if (parentValue != null) {\n        // only parent value present\n        if (Array.isArray(parentValue)) {\n          let exclude;\n          if (mutuallyExclusive != null && (exclude = currentOptions[mutuallyExclusive])) {\n            mergedOptions[key] = parentValue.filter(value => !exclude.includes(value));\n          } else {\n            mergedOptions[key] = parentValue.slice();\n          }\n        } else {\n          mergedOptions[key] = parentValue;\n        }\n      }\n    } else if (parentValue == null) {\n      // only current value present\n      if (Array.isArray(currentValue)) {\n        mergedOptions[key] = currentValue.slice();\n      } else {\n        mergedOptions[key] = currentValue;\n      }\n    } else {\n      // both current and parent values present\n      if (Array.isArray(currentValue)) {\n        let exclude;\n        if (mutuallyExclusive != null && (exclude = currentOptions[mutuallyExclusive])) {\n          mergedOptions[key] = [\n            ...currentValue,\n            ...parentValue.filter(value => !currentValue.includes(value) && !exclude.includes(value))\n          ];\n        } else {\n          mergedOptions[key] = [\n            ...currentValue,\n            ...parentValue.filter(value => !currentValue.includes(value)) // dedup\n          ];\n        }\n      } else {\n        mergedOptions[key] = currentValue;\n      }\n    }\n  }\n  return mergedOptions;\n}\n\nexports.merge = merge;\n\n/** Populates default values on a parsed options result. */\nfunction addDefaults(config, options) {\n  for (const [key, { default: defaultValue }] of Object.entries(config)) {\n    if (options[key] == null && defaultValue != null) {\n      options[key] = defaultValue;\n    }\n  }\n  return options;\n}\n\nexports.addDefaults = addDefaults;\n","/**\n * @fileoverview Recursive mkdir.\n * @license\n * Copyright 2010 James Halliday (mail@substack.net)\n *\n * This project is free software released under the MIT/X11 license:\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\nconst path = require(\"path\");\nconst fs = require(\"fs\");\nconst process = require(\"process\"); // ensure shim\n\nmodule.exports = function mkdirp(p, opts, made) {\n  if (!opts || typeof opts !== \"object\") {\n    opts = { mode: opts };\n  }\n  var mode = opts.mode;\n  if (mode === undefined) {\n    mode = 0o777 & (~process.umask());\n  }\n  if (!made) made = null;\n  p = path.resolve(p);\n  try {\n    fs.mkdirSync(p, mode);\n    made = made || p;\n  } catch (err0) {\n    switch (err0.code) {\n      case \"ENOENT\":\n        made = mkdirp(path.dirname(p), opts, made);\n        mkdirp(p, opts, made);\n        break;\n      default:\n        var stat;\n        try {\n          stat = fs.statSync(p);\n        } catch (err1) {\n          throw err0;\n        }\n        if (!stat.isDirectory()) throw err0;\n        break;\n    }\n  }\n  return made;\n};\n","/**\n * @fileoverview File finding utility.\n * @license Apache-2.0\n */\n\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nfunction findFiles(dirname, filter) {\n  var out = [];\n  fs.readdirSync(dirname).forEach(name => {\n    if (fs.statSync(path.join(dirname, name)).isDirectory()) {\n      findFiles(path.join(dirname, name), filter).forEach(iname => out.push(name + \"/\" + iname));\n    } else if (!filter || typeof filter === \"function\" ? filter(name) : filter.test(name)) {\n      out.push(name);\n    }\n  });\n  return out;\n}\n\nexports.files = findFiles;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__12__;","if(typeof __WEBPACK_EXTERNAL_MODULE__13__ === 'undefined') {var e = new Error(\"Cannot find module 'assemblyscript'\"); e.code = 'MODULE_NOT_FOUND'; throw e;}\nmodule.exports = __WEBPACK_EXTERNAL_MODULE__13__;"],"sourceRoot":""}